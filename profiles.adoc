[[riscv-doc-template]]
:description: Short, text description of spectâ€¦
:company: RISC-V
:revdate: March 27, 2022
:revnumber: 0.5
:revremark: This document is in Discussion state.  Change should be expected.
:url-riscv: http://riscv.org
:doctype: book
:preface-title: Preamble
:colophon:
:appendix-caption: Appendix
:imagesdir: images
:title-logo-image: image:riscv-images/risc-v_logo.png[pdfwidth=3.25in,align=center]
// Settings:
:experimental:
:reproducible:
:WaveDromEditorApp: wavedrom-cli
:imagesoutdir: images
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:sectnumlevels: 5
:toclevels: 5
:toc: left
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: coderay
endif::[]
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:xrefstyle: short
:numbered:
:stem: latexmath
:le: &#8804;
:ge: &#8805;
:ne: &#8800;
:approx: &#8776;
:inf: &#8734;

:sectnums!:

= RISC-V Profiles

//: This is the Preable

[WARNING]
.This document is in the link:http://riscv.org/spec-state[Discussion state]
====
Assume everything can change. This document is not complete yet and was 
created only for the purpose of conversation outside of the document.

*This is only an initial proposal and is likely to change substantially if it is standardized.*
====

:sectnums:

== Introduction

RISC-V was designed to provide a highly modular and extensible
instruction set, and includes a large and growing set of standard
extensions.  In addition, users may add their own custom
extensions. This flexibility can be used to highly optimize a
specialized design by including only the exact set of ISA features
required for an application, but the same flexibility also leads to a
combinatorial explosion in possible ISA choices.  Profiles specify a
much smaller common set of ISA choices that capture the most value for
most users, and which thereby enable the software community to focus
resources on building a rich software ecosystem.

NOTE: Another pragmatic concern is the long and unwieldy ISA strings
required to encode common sets of extensions, which will continue to
grow as new extensions are defined.

Each profile is built on a standard base ISA plus a set of mandatory
ISA extensions, and provides a small set of standard ISA options to
extend the mandatory components.  Profiles provide a convenient
shorthand for describing the ISA portions of hardware and software
platforms, and also guide the development of common software
toolchains shared by different platforms that use the same profile.
The intent is that the software ecosystem focus on supporting the
profiles' mandatory base and standard options, instead of attempting
to support every possible combination of individual extensions.
Similarly, hardware vendors should aim to structure their offerings
around standard profiles to increase the likelihood their designs will
have mainstream software support.

NOTE: Profiles are not intended to prohibit the use of combinations of
individual ISA extensions or the addition of custom extensions, which
can continue to be used for more specialized applications albeit
without the expectation of widespread software support.

NOTE: As RISC-V evolves over time, the set of ISA features will grow,
and new platforms will be added that may need different profiles.  To
manage this evolution, RISC-V is adopting a model of regular annual
releases of new ISA profiles, following an ISA roadmap managed by the
RISC-V Technical Steering Committee.  The architecture profiles will
also be used for branding and to advertise compatibility with the
RISC-V standard.

This document describes the general structure of RISC-V architecture
profiles and also the specifics of the first two families of
architecture profiles for application processors: RVA20 and RVA22.

NOTE: Other profiles are under development: RVI20 for basic RISC-V
unprivileged software compatibility, and RVM20 and RVM22 for
microcontroller platforms and these will be added in a future version
of this document.

== Profiles versus Platforms

Profiles only describe ISA features, not a complete execution
environment.

A _software_ _platform_ is a specification for an execution
environment, in which software targeted for that software platform can
run.

A _hardware_ _platform_ is a specification for a hardware system
(which can be viewed as a physical realization of an execution
environment).

Both software and hardware platforms include specifications for many
features beyond details of the ISA used by RISC-V harts in the
platform (e.g., boot process, calling convention, behavior of
environment calls, discovery mechanism, presence of certain
memory-mapped hardware devices, etc.).  Architecture profiles factor
out ISA-specific definitions from platform definitions to allow ISA
profiles to be reused across different platforms, and to be used by
tools (e.g., compilers) that are common across many different
platforms.

A platform can add additional constraints on top of those in a
profile.  For example, mandating an extension that is a standard
option in the underlying profile, or constraining some
implementation-specific parameter in the profile to lie within a
certain range.

A platform cannot remove constraints from a profile.

NOTE: A new profile should be proposed if existing profiles do not
match the needs of a new platform.

== Components of a Profile

=== Profile Family

Every profile is a member of a _profile_ _family_.  A profile family
is a set of profiles that share the same base ISA but which vary in
highest-supported privilege mode.  The initial three types of family
are:

- generic unprivileged instructions (I)
- microcontrollers for embedded systems (M)
- application processors running rich operating systems (A)

NOTE: More profile families may be added over time.

A profile family may be updated no more than annually, and the release
calendar year is treated as part of the profile family name.

Each profile family is described in more detail below.

=== Profile Privilege Mode

RISC-V has a layered architecture supporting multiple privilege modes,
and most RISC-V platforms support more than one privilege mode.
Software is usually written assuming a particular privilege mode
during execution.  For example, application code is written assuming
it will be run in user mode, and kernel code is written assuming it
will be run in supervisor mode.

NOTE: Software can be run in a mode different than the one for which
it was written. For example, privileged code using privileged ISA
features can be run in a user-mode execution environment, but will
then cause traps into the enclosing execution environment when
privileged instructions are executed.  This behavior might be
exploited, for example, to emulate a privileged execution environment
using a user-mode execution environment.

In general, available instructions vary by privilege mode, and the
behavior of RISC-V instructions can depend on the current privilege
mode.  For this reason, there are separate profiles for each
privileged mode that a profile family supports.

A profile will specify the behavior of any contained traps within the
privilege modes included in the profile.

A profile may specify that certain conditions will cause a requested
trap (such as an `ecall` made in the highest-supported privilege mode)
or fatal trap to the enclosing execution environment.  The profile
does not specify the behavior of the enclosing execution environment
in handling requested or fatal traps.

NOTE: In general, a profile can be implemented by an execution
environment using any hardware or software technique that provides
compatible functionality, up to and including pure software emulation.

A profile does not specify any invisible traps.

NOTE: In particular, a profile does not constrain how invisible traps
to a more-privileged mode can be used to emulate profile features.

The profile for a privilege mode describes the ISA features for an
execution environment that has the eponymous privilege mode as the
most-privileged mode available, but also includes all supported
lower-privilege modes.  For example, an S-mode profile includes U-mode
as well as S-mode and describes the behavior of instructions when
running in different modes in an S-mode execution environment, such as
how an `ecall` instruction in U-mode causes a contained trap into an
S-mode handler whereas an `ecall` in S-mode causes a requested trap
out to the execution environment.

A more-privileged profile can always support running software to
implement a less-privileged profile from the same profile family.  For
example, a platform supporting the S-mode profile can run a
supervisor-mode operating system that provides user-mode execution
environments supporting the U-mode profile.

NOTE: Instructions in a U-mode profile, which are all executed in user
mode, have potentially different behaviors than instructions executed
in user mode in an S-mode profile.  For this reason, a U-mode profile
cannot be considered a subset of an S-mode profile.

=== Profile ISA Features

An architecture profile has a mandatory base instruction set (RV32I or
RV64I).

NOTE: RV32I and RV64I are the only currently ratified base ISAs.

In addition, the profile groups all ratified ISA extensions for
that base ISA into four categories:

. Mandatory
. Supported Optional
. Unsupported Optional
. Incompatible

As the name implies, _Mandatory_ _ISA_ _extensions_ are a required
part of the profile.  Implementations of the profile must provide
these.  The combination of the profile base ISA plus the mandatory ISA
extensions are termed the profile _mandates_, and software using the
profile can assume these always exist.

The _Supported_ _Optional_ category (also known as _supported_
_options_) is expected to be generally supported by the software
ecosystem for this profile.

NOTE: The level of "support" for Supported Optional extension will
likely vary greatly among different software components supporting a
profile.  Users would expect that software claiming compatibility with
a profile would make use of any available supported options, but as a
bare minimum software should not report errors or warnings when
supported options are present in a system.

A supported option may comprise many individually named and ratified
extensions but the option requires all consitituent extensions are
present, i.e., proper subsets of a supported option are not a
supported option.  In particular, unless explicitly listed as a
supported option, individual extensions are not by themselves a
supported option even when required as part of a supported option.

NOTE: Supported options effectively describe the granularity at which
the broad software ecosystem is expected to cope with combinations of
extensions.

_Unsupported_ _Optional_ _Extensions_ are those that are optional, but
which are not expected to be generally supported by the software
ecosystem as an option.  Individual extensions that are components of
a supported option are categorized as unsupported optional extensions
if not explicitly listed as a supported option.  Other extensions that
are not part of a supported option but which have no conflict with
profile mandates or supported options are also listed as unsupported
options.

NOTE: Software is not required to be able to support these extensions
to claim compatibility with a profile, but may choose to provide
support.  For individual unsupported extensions that are a component
of a supported option, software is not expected to cope with
separately enabling the unsupported individual extensions and may, but
is not required to, error or report warnings if they are present but
not part of a complete supported option.

_Incompatible_ _extensions_ are those that conflict with the base or
optional extensions.  Software can assume these extensions are not
present.

All components of a ratified profile must themselves have been
ratified.

NOTE: Extensions that are ratified after a given profile is released
are either Unsupported Optional or Incompatible for that profile.  A
later release of a profile may choose to move the new extension to
Mandatory or Supported Optional categories.

Platforms may provide a discovery mechanism to determine what optional
extensions are present.

=== Profile Naming Convention

A profile name is a string comprised of, in order:

. Prefix *RV* for RISC-V.
. A specific profile family name string.  Initially a single letter (*I*, *M*, or *A*), but later profiles may have longer family name strings.
. A numeric string giving the first complete calendar year for which
the profile is ratified, represented as number of years after year
2000, i.e., *20* for profiles built on specifications ratified during 2019. The year string will be longer than two digits in the next century.
. A privilege mode (*U*, *S*, *M*).  Hypervisor support is treated as an option.
. A base ISA XLEN specifier (*32*, *64*).

The initial profiles based on specifications ratified in 2019 are:

- RVI20U32 basic unprivileged instructions for RV32I
- RVI20U64 basic unprivileged instructions for RV64I
- RVM20U32, RVM20S32, RVM20M32 profiles for microcontrollers based on RV32I
- RVM20U64, RVM20S64, RVM20M64 profiles for microcontrollers based on RV64I
- RVA20U64, RVA20S64 64-bit application-processor profiles

NOTE: This document currently only includes the RVAx64 profiles, which
are the first to be defined.  The others will be added later.







== RVI20 Profiles

The RVI20 profiles document the initial set of unprivileged
instructions.  These provide a generic target for software toolchains
and represent the minimum level of compatibility with RISC-V ratified
standards.  The two profiles RVI20U32 and RVIU64 correspond to the
RV32I and RV64I base ISAs respectively.

NOTE: These are designed as _unprivileged_ profiles as opposed to
_user_-_mode_ profiles.  Code using this profile can run in any
privilege mode, and so requested and fatal traps may be horizontal
traps into an execution environment running in the same privilege
mode.

=== RVI20U32

RVI20U32 specifies the ISA features available to generic unprivileged
execution environments.

==== RVI20U32 Mandatory Base

RV32I is the mandatory base ISA for RVI20U32.

The `ecall` instruction causes a requested trap to the execution
environment.

Misaligned loads and stores may not be supported.

The `fence.tso` instruction is mandatory.

NOTE: The `fence.tso` instruction was incorrectly described as
optional in the 2019 ratified specifications. However, `fence.tso` is
encoded within the standard `fence` encoding such that implementations
must treat it as a simple global fence if they do not natively support
TSO-ordering optimizations.  As software can always assume without any
penalty that `fence.tso` is being exploited by a hardware
implementation, there is no advantage to making the instruction a
supported option.  Later versions of the unprivileged ISA
specifications correctly indicate that `fence.tso` is mandatory.

==== RVI20U32 Mandatory Extensions

There are no mandatory extensions for RVI20U32.

==== RVI20U32 Supported Optional Extensions

- *M* Integer multiplication and divison.

- *A* Atomic instructions.

- *F* Single-precision floating-point instructions.
  
- *D* Double-precision floating-point instructions.

- *C* Compressed Instructions.

- *Zifencei* Instruction-fetch fence instruction.

- Misaligned loads and stores may be supported.

- *Zicntr* Basic counters.

- *Zihpm* Hardware performance counters.

NOTE: Counters and timers (now known as Zicntr and Zihpm) were frozen
but not ratified in 2019, as they were removed from the base ISAs
during the ratification process.  Due to an oversight they were not
later ratified.  As they are required for the RVA20 and RVA22
profiles, the proposal is to ratify these extensions in 2022 and
retroactively add to the 2020 and 2022 profiles as an exception.

==== RVI20U32 Unsupported Optional Extensions

- *Zicsr* CSR instructions.

NOTE: The Zicsr extension is not supported independent of the Zicntr or
F extensions.

- *Q* Quad-precision floating-point instructions.

NOTE: The rationale to make Q an unsupported extension is that
quad-precision floating-point is unlikely to be implemented in
hardware, and so we do not require or expect software to expend effort
optimizing use of Q instructions in case they are present.

==== RVI20U32 Incompatible Extensions

None.

NOTE: The RVI20U32 specification only categorizes extensions ratified in
2019 (except for Zicntr and Zihpm).

=== RVI20U64

RVI20U64 specifies the ISA features available to generic unprivileged
execution environments.

==== RVI20U64 Mandatory Base

RV64I is the mandatory base ISA for RVI20U64.

The `ecall` instruction causes a requested trap to the execution
environment.

Misaligned loads and stores may not be supported.

The `fence.tso` instruction is mandatory.

NOTE: The `fence.tso` instruction was incorrectly described as
optional in the 2019 ratified specifications. However, `fence.tso` is
encoded within the standard `fence` encoding such that implementations
must treat it as a simple global fence if they do not natively support
TSO-ordering optimizations.  As software can always assume without any
penalty that `fence.tso` is being exploited by a hardware
implementation, there is no advantage to making the instruction a
supported option.  Later versions of the unprivileged ISA
specifications correctly indicate that `fence.tso` is mandatory.

==== RVI20U64 Mandatory Extensions

There are no mandatory extensions for RVI20U64.

==== RVI20U64 Supported Optional Extensions

- *M* Integer multiplication and divison.

- *A* Atomic instructions.

- *F* Single-precision floating-point instructions.
  
- *D* Double-precision floating-point instructions.

- *C* Compressed Instructions.

- *Zifencei* Instruction-fetch fence instruction.

- Misaligned loads and stores may be supported.

- *Zicntr* Basic counters.

- *Zihpm* Hardware performance counters.

NOTE: Counters and timers (now known as Zicntr and Zihpm) were frozen
but not ratified in 2019, as they were removed from the base ISAs
during the ratification process.  Due to an oversight they were not
later ratified.  As they are required for the RVA20 and RVA22
profiles, the proposal is to ratify these extensions in 2022 and
retroactively add to the 2020 and 2022 profiles as an exception.

==== RVI20U64 Unsupported Optional Extensions

- *Zicsr* CSR instructions.

NOTE: The Zicsr extension is not supported independent of the Zicntr or
F extensions.

- *Q* Quad-precision floating-point instructions.

NOTE: The rationale to make Q an unsupported extension is that
quad-precision floating-point is unlikely to be implemented in
hardware, and so we do not require or expect software to expend effort
optimizing use of Q instructions in case they are present.

==== RVI20U64 Incompatible Extensions

None.

NOTE: The RVI20U64 specification only categorizes extensions ratified in
2019 (except for Zicntr and Zihpm).


== RVA20 Profiles

The RVA20 profiles are intended to be used for 64-bit application
processors running rich OS stacks.  Only user-mode (RVA20U64) and
supervisor-mode (RVA20S64) profiles are specified in this family.

NOTE: There is no machine-mode profile currently defined for
application processor families.  A machine-mode profile for
application processors would only be used in specifying platforms for
portable machine-mode software. Given the relatively low volume of
portable M-mode software in this domain, the wide variety of potential
M-mode code, and the very specific needs of each type of M-mode
software, we are not specifying individual M-mode ISA requirements in
the A-family profiles.

NOTE: Only XLEN=64 application processor profiles are currently
defined.  It would be possible to also define very similar XLEN=32
variants.

=== RVA20U64 Profile

The RVA20U64 profile specifies the ISA features available to user-mode
execution environments in 64-bit applications processors.  This is the
most important profile within the application processor family in
terms of the amount of software that targets this profile.

RVA20U64 has one unprivileged supported option (Zihpm).

==== RVA20U64 Mandatory Base

RV64I is the mandatory base ISA for RVA20U64.

The `ecall` instruction causes a requested trap to the execution
environment.

The `fence.tso` instruction is mandatory.

NOTE: The `fence.tso` instruction was incorrectly described as
optional in the 2019 ratified specifications. However, `fence.tso` is
encoded within the standard `fence` encoding such that implementations
must treat it as a simple global fence if they do not natively support
TSO-ordering optimizations.  As software can always assume without any
penalty that `fence.tso` is being exploited by a hardware
implementation, there is no advantage to making the instruction a
supported option.  Later versions of the unprivileged ISA
specifications correctly indicate that `fence.tso` is mandatory.

==== RVA20U64 Mandatory Extensions

- *M* Integer multiplication and divison.
- *A* Atomic instructions.
- *F* Single-precision floating-point instructions.
- *D* Double-precision floating-point instructions.
- *C* Compressed Instructions.
- *Zicsr*  CSR instructions.  These are implied by presence of Zicntr or F.
- *Zicntr* Basic counters.

NOTE: Counters and timers (now known as Zicntr and Zihpm) were frozen
but not ratified in 2019, as they were removed from the base ISAs
during the ratification process.  Due to an oversight they were not
later ratified.  As they are required for the RVA20 and RVA22
profiles, the proposal is to ratify these extensions in 2022 and
retroactively add to the 2020 and 2022 profiles as an exception.

- Main memory regions with both the cacheability and coherence PMAs must
  support instruction fetch, AMOArithmetic, and RsrvEventual.
- Reservation sets must be contiguous and at least 16 bytes and at most 128 bytes in size.
- Misaligned loads and stores to main memory regions with both the
  cacheability and coherence PMAs must be supported.

NOTE: Even when supported, misaligned loads and stores might execute
extremely slowly.  Standard software distributions should assume their
existence only for correctness, not for performance.

- Within main-memory regions, fetching a naturally aligned instruction of
  up to four bytes must be atomic.

NOTE: This requirement facilitates runtime patching of aligned instructions.


==== RVA20U64 Supported Optional Extensions

- *Zihpm* Hardware performance counters.

NOTE: Hardware performance counters are a supported option in RVA20.
The number of counters is platform-specific.

==== RVA20U64 Unsupported Optional Extensions

- *Q* Quad-precision floating-point instructions.

NOTE: The rationale to make Q an unsupported extension is that
quad-precision floating-point is unlikely to be implemented in
hardware, and so we do not require or expect A-profile software to
expend effort optimizing use of Q instructions in case they are
present.

- *Zifencei* Instruction-fetch fence instruction.

NOTE: Zifencei is not classed as a supported option in the user-mode
profile because it is not sufficient by itself to produce the desired
effect in a multiprogrammed multiprocessor environment without OS
support, and so the instruction cache flush should always be performed
using an OS call rather than using the `fence.i` instruction.
`fence.i` semantics can be expensive to implement for some hardware
memory hierarchy designs, and so alternative non-standard
instruction-cache coherence mechanisms can be used behind the OS
abstraction.  A separate extension is being developed for more general
and efficient instruction cache coherence.

NOTE: The execution environment must provide a means to synchronize writes to
instruction memory with instruction fetches, the implementation of which
likely relies on the Zifencei extension.
For example, RISC-V Linux supplies the `__riscv_flush_icache` system call and
a corresponding vDSO call.

==== RVA20U64 Incompatible Extensions

None.

NOTE: The RVA20 specification only categorizes extensions ratified in
2019  (except for Zicntr and Zihpm).

==== RVA20U64 Recommendations

Recommendations are not strictly mandated but are included to guide
implementers making design choices.

Implementations are strongly recommended to raise illegal-instruction
exceptions on attempts to execute unimplemented opcodes.

=== RVA20S64 Profile

The RVA20S64 profile specifies the ISA features available to a
supervisor-mode execution environment in 64-bit applications
processors.  RVA20S64 is based on privileged architecture version
1.11.

RVA20S64 has one unprivileged supported option (Zihpm) and one privileged
supported option (Sv48).

==== RVA20S64 Mandatory Base

RV64I is the mandatory base ISA for RVA20S64.

An `ecall` in user mode causes a contained trap to supervisor mode.
An `ecall` in supervisor mode causes a requested trap to the execution
environment.

==== RVA20S64 Mandatory Extensions

The following unprivileged extensions are mandatory:

- The RVA20S64 mandatory unprivileged extensions include all the
mandatory unprivileged extensions in RVA20U64.

- *Zifencei*  Instruction-Fetch Fence.

NOTE: Zifencei is mandated as it is the only standard way to support
instruction-cache coherence in RVA20 application processors.  A new
instruction-cache coherence mechanism is under development which might
be added as an option in the future.

The following privileged extensions are mandatory:

- *Ss1p11*  Privileged Architecture version 1.11.

- *Sv39* Page-Based 39-bit Virtual-Memory System.

- In addition to Sv39, the `satp` mode Bare must be supported.

- Main memory regions with both the cacheability and coherence PMAs must
  support hardware page-table reads.
  Such regions must additionally support hardware page-table writes if
  any harts support hardware page-table writes.

- `stvec.MODE` must be capable of holding the value 0 (Direct).  When
  `stvec.MODE=Direct`, `stvec.BASE` must be capable of holding any
  valid four-byte-aligned address.

- `stval` must be written with the faulting virtual address for load,
  store, and instruction page-fault, access-fault, and misaligned
  exceptions, and for breakpoint exceptions other than those caused by
  execution of the `ebreak` or `c.ebreak` instructions.  For
  illegal-instruction exceptions, `stval` must be written with the
  faulting instruction.

==== RVA20S64 Supported Optional Extensions

RVA20U64 has one unprivileged supported option.

- *Zihpm* Hardware performance counters.

NOTE: The number of counters is platform-specific.

RVA20S64 has the following privileged supported options:

- *Sv48* Page-Based 48-bit Virtual-Memory System.

NOTE: There may be additional options and parameters in the privileged
architecture that should be detailed here.

==== RVA20S64 Unsupported Optional Extensions

The following unprivileged extensions are unsupported:

- *Q*  Quad-Precision Floating-Point.

- *N* User-Level Interrupts.

NOTE: The unprivileged N extension for user-level interrupts has _not_
been ratified, but the ratified privileged architecture v1.11 text
refers to user-level interrupts.

The following privileged extensions are unsupported:

- *sstatus.UXL!=64*  Different User-Mode XLEN.

NOTE: This extension is not expected to be widely used, as RISC-V
applications processors were initially, and are still predominantly,
XLEN=64, avoiding the need to support legacy XLEN=32 binaries.
Applications that want to use 32-bit pointers to reduce memory
footprint should use a forthcoming RV64 ILP32 ABI instead.

- *stvec.MODE=Vectored*  Hardware Trap Vectoring.

NOTE: Hardware vectoring of exception/interrupt traps is not generally
used by rich operating systems.

==== RVA20S64 Incompatible Extensions

There are no incompatible unprivileged extensions.

The following are incompatible privileged extensions:

- *IALIGN!=16* Masking of `sepc[1]` bit.

NOTE: Increasing IALIGN to 32 by disabling compressed instructions is
incompatible as the RVA20S64 profile mandates compressed instruction
support.  Systems supporting dynamic switching must turn on compressed
instruction support (e.g., by setting the `misa.c` bit) before
creating a supervisor-mode execution environment following the
RVA20S64 profile.




== RVA22 Profiles

The RVA22 profiles are intended to be used for 64-bit application
processors running rich OS stacks.  Only user-mode (RVA22U64) and
supervisor-mode (RVA22S64) profiles are specified in this family.

=== RVA22U64 Profile

The RVA22U64 profile specifies the ISA features available to user-mode
execution environments in 64-bit applications processors.  This is the
most important profile within the application processor family in
terms of the amount of software that targets this profile.

RVA22U64 has 4 supported options (Zfh, V, Zkn, Zks).

==== RVA22U64 Mandatory Base

RV64I is the mandatory base ISA for RVA22U64, including mandatory `fence.tso`.

NOTE: Later versions of the RV64I unprivileged ISA specification
ratified in 2021 made clear that `fence.tso` is mandatory.

The `ecall` instruction causes a requested trap to the execution
environment.

==== RVA22U64 Mandatory Extensions

The following mandatory extensions were present in RVA20U64.

- *M* Integer multiplication and divison.
- *A* Atomic instructions.
- *F* Single-precision floating-point instructions.
- *D* Double-precision floating-point instructions.
- *C* Compressed Instructions.
- *Zicsr*  CSR instructions.  These are implied by presence of F.
- *Zicntr* Base counters and timers.
- *Zihpm* Hardware performance counters.

NOTE: Counters and timers (now known as Zicntr and Zihpm) were frozen
but not ratified in 2019, as they were removed from the base ISAs
during the ratification process.  Due to an oversight they were not
later ratified.  As they are required for the RVA20 and RVA22
profiles, the proposal is to ratify these extensions in 2022 and
retroactively add to the 2020 and 2022 profiles as an exception.

- Main memory regions with both the cacheability and coherence PMAs must
  support instruction fetch, AMOArithmetic, and RsrvEventual.
- Misaligned loads and stores to main memory regions with both the
  cacheability and coherence PMAs must be supported.

NOTE: Even when supported, misaligned loads and stores might execute
extremely slowly.  Standard software distributions should assume their
existence only for correctness, not for performance.

- Within main-memory regions, fetching a naturally aligned instruction of
  up to four bytes must be atomic.

NOTE: This requirement facilitates runtime patching of aligned instructions.

The following mandatory feature was further restricted in RVA22U64:

- Reservation sets are a maximum of 64 bytes, and must be naturally aligned to a power-of-2 byte-address boundary.

NOTE: The maximum reservation size has been reduced to match the
required cache line size.  The minimum reservation size is effectively
set by the instructions in the mandatory A extension.

The following mandatory extensions are new for RVA22U64.

- *Zihintpause* Pause instruction.

NOTE: While the `pause` instruction is a HINT can be implemented as a
NOP and hence trivially supported by hardware implementers, its
inclusion in the mandatory extension list signifies that software
should use the instruction whenever it would make sense and that
implementors are expected to exploit this information to optimize
hardware execution.

- *Zba* Address computation.
- *Zbb* Basic bit manipulation.
- *Zbs* Single-bit instructions.

Cache blocks must be 64 bytes in size, naturally aligned in the
address space.

NOTE: While the general RISC-V specifications are agnostic to cache
block size, selecting a common cache line size simplifies the
specification and use of the following cache-block extensions within
the application processor profile. Software does not have to query a
discovery mechanism and/or provide dynamic dispatch to the appropriate
code. We choose 64 bytes at it is effectively an industry
standard. Implementations may use longer cache lines to reduce tag
cost provided they use 64-byte sub-blocks to remain
compatible. Implementations may use shorter cache lines provided they
sequence cache operations across the multiple cache lines comprising a
64-byte block to remain compatible.

- *Zicbom* Cache-Block Management Operations.
- *Zicbop* Cache-Block Prefetch Operations.

NOTE: As with other HINTS, the inclusion of prefetches in the
mandatory set of extensions indicates that software should generate
these instructions where they are expected to be useful, and hardware
is expected to exploit that information.

- *Zicboz* Cache-Block Zero Operations.

- *Zfhmin* Half-Precision Floating-point transfer and convert.

NOTE: Zfhmin is a small extension that adds support to load/store and
convert IEEE FP16 numbers to and from IEEE FP32 format.  The hardware
cost for this extension is low, and mandating the extension avoids
adding an option to the profile.

- *Zkt* Data-independent execution time.

NOTE: Zkt requires a certain subset of integer instructions execute
with data-independent latency.  Mandating this feature enables
portable libraries for safe basic cryptographic operations. It is
expected that application processors will naturally have this property
and so implementation cost is low, if not zero, in most systems that
would support RVA22.

==== RVA22U64 Supported Options

The following supported options are new for RVA22U64:

- *Zfh* Half-Precision Floating-Point.

NOTE: A future profile might mandate Zfh.

- *V* Vector Extension.

NOTE: A future profile might mandate V.

- *Zkn* Scalar Crypto NIST Algorithms.
- *Zks* Scalar Crypto ShangMi Algorithms.

NOTE: The scalar crypto extensions are expected to be superceded by
vector crypto standards in future profiles, and the scalar extensions
may move to "unsupported optional" category once the vector crypto is
present.

==== RVA22U64 Unsupported Optional Extensions

The following unsupported optional extensions were present in RVA20U64:

- *Q* Quad-precision floating-point instructions.

- *Zifencei* Instruction-fetch fence instruction.

The following unsupported optional extensions were added in RVA22U64:

- *Zbc* Carryless multiply

NOTE: The remaining carryless multiply instructions that are not
included in the supported scalar crypto options are not considered
sufficiently important to make a supported option in the profile.
Possibly the remaining instructions could be merged into the supported
option.

- *Zbkb*, *Zbkc*, *Zbkx*, *Zknd*, *Zkne*, *Zknh*, *Zksed*, *Zksh*  Scalar crypto subset extensions.

NOTE: The smaller component scalar crypto extensions are not provided
as separately supported options in the profile.  Profile implementers
should provide all of the instructions in a given algorithm suite as
part of the Zkn or Zks supported options.

- *Zve32f*, *Zve32x*, *Zve64d*, *Zve64f*, *Zve64x* Vector subset extensions.

NOTE: The smaller vector extensions are not provided as separately
supported options in the profile. The full V extension is specified as
the supported option for application processors.

- *Zkr* Entropy CSR

NOTE: Access to the entropy source in a system is usually carefully
controlled.  While the design supports unprivileged access to the
entropy source, this is unlikely to be often used.

==== RVA22U64 Incompatible Extensions

There were no incompatible extensions in RVA20U64.

The following incompatible extensions were added for RVA22U64.

- *Zfinx*, *Zdinx*, *Zhinx*, *Zhinxmin* Floating-point in X registers.

NOTE: These are incompatible with the profile mandates to support the
F and D extensions.

==== RVA22U64 Recommendations

Recommendations are not strictly mandated but are included to guide
implementers making design choices.

Implementations are strongly recommended to raise illegal-instruction
exceptions on attempts to execute unimplemented opcodes.

=== RVA22S64 Profile

The RVA22S64 profile specifies the ISA features available to a
supervisor-mode execution environment in 64-bit applications
processors.  RVA22S64 is based on privileged architecture version
1.12.

RVA22S64 has 4 unprivileged supported options (Zfh, V, Zkn, Zks)
and 6 privileged supported options (Sv48, Sv57, Sstc, Sscofpmf, Zkr, H).

==== RVA22S64 Mandatory Base

RV64I is the mandatory base ISA for RVA22U64, including mandatory `fence.tso`.

NOTE: Later versions of the RV64I unprivileged ISA specification
ratified in 2021 made clear that `fence.tso` is mandatory.

An `ecall` in user mode causes a contained trap to supervisor mode.
An `ecall` in supervisor mode causes a requested trap to the execution
environment.

==== RVA22S64 Mandatory Extensions

The following unprivileged extensions are mandatory:

- The RVA22S64 mandatory unprivileged extensions include all the
mandatory unprivileged extensions in RVA22U64.

- *Zifencei*  Instruction-Fetch Fence.

NOTE: Zifencei is mandated as it is the only standard way to support
instruction-cache coherence in RVA22 application processors.  A new
instruction-cache coherence mechanism is under development which might
be added as an option in the future.

The following privileged extensions are mandatory:

- *Ss1p12*  Privileged Architecture version 1.12.

- *Sv39* Page-Based 39-bit Virtual-Memory System.

- In addition to Sv39, the `satp` mode Bare must be supported.

- Main memory regions with both the cacheability and coherence PMAs must
  support hardware page-table reads.
  Such regions must additionally support hardware page-table writes if
  any harts support hardware page-table writes.

- stvec.MODE must be capable of holding the value 0 (Direct).
  When stvec.MODE=Direct,
  stvec.BASE must be capable of holding any valid four-byte-aligned address.

- stval must be written with the faulting virtual address for load, store, and
  instruction page-fault, access-fault, and misaligned exceptions, and for
  breakpoint exceptions other than those caused by execution of the EBREAK or
  C.EBREAK instructions.
  For illegal-instruction exceptions, stval must be written with the faulting
  instruction.

- For any hpmcounter that is not read-only zero, the corresponding bit
  in scounteren must be writable.

- sstatus.UBE must not be read-only 1.

- *Svpbmt* Page-Based Memory Types

- *Svnapot* NAPOT Translation Contiguity

- *Svinval* Fine-Grained Address-Translation Cache Invalidation

==== RVA22S64 Supported Optional Extensions

All RVA22U64 supported optional extensions (Zfh, V, Zkn, Zks).

The privileged optional extensions are:

- *Sv48* Page-Based 48-bit Virtual-Memory System.

- *Sv57* Page-Based 57-bit Virtual-Memory System.

- *Sstc* supervisor-mode timer interrupts.

NOTE: Sstc was not made mandatory in RVA22S64 as it is a more
disruptive change affecting system-level architecture, and will take
longer for implementations to adopt.  It is expected to be made
mandatory in the next profile release.

- *Sscofpmf* Count Overflow and Mode-Based Filtering.

NOTE: Platforms may choose to mandate the presence of Sscofpmf.

- *Zkr*  Entropy CSR.

- *H* The hypervisor extension.

When the hypervisor extension is implemented, the following are also mandatory:

- *Smstateen* State-enable extension.  The supervisor-mode
   (`sstateen0-3`) and hypervisor-mode (`hstateen0-3`) state-enable
   registers must be provided.

NOTE: The extension specification is named as an M-mode extension as
it includes M-mode features, but also has supervisor-mode components.
Only the supervisor/hypervisor-mode-visible components are mandated in
the RVA22S64 profile.  These registers are not mandated or
supported options without the hypervisor extension, as
there are no RVA22S64 supported options with relevant state to
control in the absence of the hypervisor extension.

- For any `hpmcounter` that is not read-only zero, the corresponding bit
  in `hcounteren` must be writable.

- `vstval` must be written in all cases described above for `stval`.

- `htval` must be written with the faulting guest physical address in all
  circumstances permitted by the ISA.

- `vstvec.MODE` must be capable of holding the value 0 (Direct).
  When `vstvec.MODE`=Direct,
  `vstvec.BASE` must be capable of holding any valid four-byte-aligned address.

- All translation modes supported in `satp` must be supported in `vsatp`.

- For each supported virtual memory scheme SvNN supported in `satp`, the
  corresponding hgatp SvNNx4 mode must be supported.  The `hgatp` mode Bare
  must also be supported.

==== RVA22S64 Unsupported Optional Extensions

Unprivileged unsupported optional extensions are:

- RVA22S64 has the same unsupported optional extensions as RVA22U64 except for Zkr.

The following privileged extensions are unsupported:

- *sstatus.UXL!=64*  Different User-Mode XLEN.

NOTE: This extension is not expected to be widely used.

- *stvec.MODE=Vectored*  Hardware Trap Vectoring.

NOTE: Hardware vectoring of exception/interrupt traps is not generally
used by rich operating systems.

==== RVA22S64 Incompatible Extensions

Incompatible unprivileged extensions are:

- All RVA22U64 incompatible extensions

The following are incompatible privileged extensions:

- *IALIGN!=16* Masking of `sepc[1]` bit.

NOTE: Increasing IALIGN to 32 by disabling compressed instructions is
incompatible as the RVA20S64 profile mandates compressed instruction
support.  Systems supporting dynamic switching must turn on compressed
instruction support (e.g., by setting the `misa.c` bit) before
creating a supervisor-mode execution environment following the
RVA20S64 profile.

==== RVA22S64 Recommendations

- Implementations are strongly recommended to raise illegal-instruction
  exceptions when attempting to execute unimplemented opcodes.


== Glossary of ISA Extensions

The following unprivileged ISA extensions are defined in Volume I
of the https://github.com/riscv/riscv-isa-manual[RISC-V Instruction Set Manual].

- M Extension for Integer Multiplication and Division
- A Extension for Atomic Memory Operations
- F Extension for Single-Precision Floating-Point
- D Extension for Double-Precision Floating-Point
- Q Extension for Quad-Precision Floating-Point
- C Extension for Compressed Instructions
- Zifencei Instruction-Fetch Synchronization Extension
- Zicsr Extension for Control and Status Register Access
- Zicntr Extension for Basic Performance Counters
- Zihpm Extension for Hardware Performance Counters
- Zihintpause Pause Hint Extension
- Zfh Extension for Half-Precision Floating-Point
- Zfhmin Minimal Extension for Half-Precision Floating-Point
- Zfinx Extension for Single-Precision Floating-Point in x-registers
- Zdinx Extension for Double-Precision Floating-Point in x-registers
- Zhinx Extension for Half-Precision Floating-Point in x-registers
- Zhinxmin Minimal Extension for Half-Precision Floating-Point in x-registers

The following privileged ISA extensions are defined in Volume II
of the https://github.com/riscv/riscv-isa-manual[RISC-V Instruction Set Manual].

- Sv32 Page-based Virtual Memory Extension, 32-bit
- Sv39 Page-based Virtual Memory Extension, 39-bit
- Sv48 Page-based Virtual Memory Extension, 48-bit
- Sv57 Page-based Virtual Memory Extension, 57-bit
- Svpbmt, Page-Based Memory Types
- Svnapot, NAPOT Translation Contiguity
- Svinval, Fine-Grained Address-Translation Cache Invalidation
- Hypervisor Extension
- Sm1p11, Machine Architecture v1.11
- Sm1p12, Machine Architecture v1.12
- Ss1p11, Supervisor Architecture v1.11
- Ss1p12, Supervisor Architecture v1.12

The following extensions have not yet been incorporated into the RISC-V
Instruction Set Manual; the hyperlinks lead to their separate specifications.

- https://github.com/riscv/riscv-bitmanip[Zba Address Computation Extension]
- https://github.com/riscv/riscv-bitmanip[Zbb Bit Manipulation Extension]
- https://github.com/riscv/riscv-bitmanip[Zbc Carryless Multiplication Extension]
- https://github.com/riscv/riscv-bitmanip[Zbs Single-Bit Manipulation Extension]
- https://github.com/riscv/riscv-crypto[Zbkb Extension for Bit Manipulation for Cryptography]
- https://github.com/riscv/riscv-crypto[Zbkc Extension for Carryless Multiplication for Cryptography]
- https://github.com/riscv/riscv-crypto[Zbkx Crossbar Permutation Extension]
- https://github.com/riscv/riscv-crypto[Zk Standard Scalar Cryptography Extension]
- https://github.com/riscv/riscv-crypto[Zkn NIST Cryptography Extension]
- https://github.com/riscv/riscv-crypto[Zknd AES Decryption Extension]
- https://github.com/riscv/riscv-crypto[Zkne AES Encryption Extension]
- https://github.com/riscv/riscv-crypto[Zknh SHA2 Hashing Extension]
- https://github.com/riscv/riscv-crypto[Zkr Entropy Source Extension]
- https://github.com/riscv/riscv-crypto[Zks ShangMi Cryptography Extension]
- https://github.com/riscv/riscv-crypto[Zksed SM4 Block Cypher Extension]
- https://github.com/riscv/riscv-crypto[Zksh SM3 Hashing Extension]
- https://github.com/riscv/riscv-crypto[Zkt Extension for Data-Independent Execution Latency]
- https://github.com/riscv/riscv-v-spec[V Extension for Vector Computation]
- https://github.com/riscv/riscv-v-spec[Zve32x Extension for Embedded Vector Computation (32-bit integer)]
- https://github.com/riscv/riscv-v-spec[Zve32f Extension for Embedded Vector Computation (32-bit integer, 32-bit FP)]
- https://github.com/riscv/riscv-v-spec[Zve32d Extension for Embedded Vector Computation (32-bit integer, 64-bit FP)]
- https://github.com/riscv/riscv-v-spec[Zve64x Extension for Embedded Vector Computation (64-bit integer)]
- https://github.com/riscv/riscv-v-spec[Zve64f Extension for Embedded Vector Computation (64-bit integer, 32-bit FP)]
- https://github.com/riscv/riscv-v-spec[Zve64d Extension for Embedded Vector Computation (64-bit integer, 64-bit FP)]
- https://github.com/riscv/riscv-CMOs[Zicbom Extension for Cache-Block Management]
- https://github.com/riscv/riscv-CMOs[Zicbop Extension for Cache-Block Prefetching]
- https://github.com/riscv/riscv-CMOs[Zicboz Extension for Cache-Block Zeroing]
- https://github.com/riscv/riscv-time-compare[Sstc Extension for Supervisor-mode Timer Interrupts]
- https://github.com/riscv/riscv-count-overflow[Sscofpmf Extension for Count Overflow and Mode-Based Filtering]
- https://github.com/riscv/riscv-state-enable[Smstateen Extension for State-enable]
